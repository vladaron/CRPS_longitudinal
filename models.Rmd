---
title: "CRPS longitidunal analsysis-Models"
output:
  html_document:  
    code_folding: hide 
    theme: flatly              
    toc: yes  
    toc_float: yes
    toc_depth: 3
    number_sections: yes                      
---

# Set up & data

```{r set_up, include = F}

library(lmerTest) #compute p values for lme4
library(lme4) #linear mixed models
library(broom) #produce summary of models
library(broom.mixed) #produce summary of models
library(purrr) #produce summary of models
library(glue) #string formatting
library(ggplot2) #vizualization
library(tidyverse) #general data handling tools
library(readxl) #excel tools
library(writexl)#excel tools
library(here) #datasets tools

# treatment contrasts of factors for lmer
options(contrasts = c("contr.treatment","contr.poly"))

knitr::opts_chunk$set(
  tidy    = TRUE,
  warning = T,
  message = T, 
  echo = T,
  comment = FALSE,
  fig.align = "defaut",
  fig.width = 8,
  fig.asp = 0.62,
  out.width = "100%"
  )

```


Below code to produce data set including outcomes variables over time and predictors at T0 only.

```{r dat_formatted}
# importing data set formatted for univariate analyses i.e., outcomes values at all timepoints
dat <- read_excel(here("data","data_formatted_20250704.xlsx"))

# selecting Modal values at T0
dat_mod <- dat |> 
  select(patient_id, redcap_event_code, Modal) |> 
  filter(redcap_event_code == 1) |> 
  select(-redcap_event_code)

# dataset for univariate analyses: Modal at T0 and outcomes values at all timepoint
dat <- full_join(subset(dat, select = -Modal), dat_mod)

# dataset formatting
dat$redcap_event_code <- factor(dat$redcap_event_code)
dat$patient_id <- factor(dat$patient_id)

# outcomes 
dat_outcomes <- dat |> 
  select(redcap_event_code, patient_id, quick_dash_score, lefsscore, bpi_pain_interference, bpi_pain_intensity, css, dichotoumous_diagnosis, EQindex, work_status, disability) 

# predictors: filtered at T0
dat_var <- dat |> 
  select( -quick_dash_score, -lefsscore, -bpi_pain_interference, -bpi_pain_intensity, -css, -dichotoumous_diagnosis, -EQindex, -work_status, -disability) |> 
  filter(redcap_event_code == "1") |> 
  select(-redcap_event_code) 

# full data set for univariate anlayses
dat_formatted <- full_join(dat_outcomes, dat_var) |> 
  arrange(patient_id) 


# dataset for univariate analyses of return to work
dat_formatted_work <- dat_formatted |> 
  filter(workingbeforecrps == 1) |> 
  mutate(return_to_work = if_else(
    work_status %in% c(5,6), 1, 0
  )) |> 
  mutate(return_to_work = factor(return_to_work)) |> 
  select(patient_id, redcap_event_code, workingbeforecrps, work_status, return_to_work, Modal, everything())

# datasets export
#write_xlsx(dat_formatted |> 
 # mutate(across(everything(), as.numeric)) |> 
 # mutate(redcap_event_code = factor(redcap_event_code))  , path = here("output", "data_formatted_20250207_test.xlsx"))


#write_xlsx(dat_formatted_work|> 
#  mutate(across(everything(), as.numeric)) |> 
 # mutate(redcap_event_code = factor(redcap_event_code)), path = here("output", "data_formatted_work_20250207_test.xlsx"))

```

# Univariate analyses

Predictors included in univariate analyses

```{r var_t0}

# importing variable names
var <- read_excel(here("data","var_test_20250207.xlsx")) |> 
  select(-age, -sex, -localization, -Z_phs_affected, -Z_phs_control) 
# adding extra variables
var$bpi_pain_interference_T1 <- NA
var$bpi_pain_intensity_T1<- NA
var$css_T1<- NA
var$dichotoumous_diagnosisc_T1<- NA
var$EQindex_T1<- NA
var$disability_T1 <- NA
var$scintigraphy_ratio <- NA
var$comorbidity_chronic_pain <- NA



```


Functions to loop over univariate analyses for predictors and outcomes.

```{r functions}

# function for univariate analyses of continuous outcomes
mod.time.new <- function(out, data_set = dat, modal = F) {
  # time is transformed in a continuous variable
  data_set <- data_set |>
    mutate(across(everything(), as.numeric)) |>
    mutate(redcap_event_code = case_when(
      redcap_event_code == "1" ~ "1",
      redcap_event_code == "2" ~ "4.5",
      redcap_event_code == "3" ~ "6",
      redcap_event_code == "4" ~ "12"
    )) |>
    mutate(redcap_event_code = as.numeric(redcap_event_code))



  # filtering the name of the outcome from the variables names (if it is also a variable)
  if (any(names(var) == out)) {
    names_var <- names(var |> select(-.data[[out]]))
  } else {
    names_var <- names(var)
  }

  if (modal == F) {
    names_var <- names_var
  } else {
    names_var <- c(names_var, "Modal")
  }

  # creating a data set in long format with VI (variables) and VD (outcome of interest)
  d <- data_set |>
    select(patient_id, redcap_event_code, age, sex, localization, .data[[out]], names_var) |>
    pivot_longer(
      cols = names_var,
      names_to = "VI",
      values_to = "VI_val"
    ) |>
    pivot_longer(
      cols = c(out),
      names_to = "VD",
      values_to = "VD_val"
    )


  # nested data frame for each VI and VD combination


  mod.quick <- d |>
    group_by(VI, VD) |>
    nest() |>
    select(VI, VD, data) |>
    mutate(
      na_check = map(.x = data, ~ na.omit(.x)) # filtering NA from the data set
    ) |>
    mutate(
      na_check_conv = map(
        .x = na_check,
        ~ if (
          VI %in% c(
            "analgesic",
            "budapest_research_criteria",
            "center",
            "conflict",
            "crps_5a",
            "crps_subtypes",
            "crps_type",
            "currently_smoking",
            "dominant_side_affected",
            "family_history_crps",
            "initial_event",
            "localization",
            "personal_historycrps",
            "physiotherapy",
            "psh",
            "psl_affected",
            "reoperated",
            "scintigraphy",
            "sex",
            "skin_color",
            "surgery",
            "triggering_event2",
            "Modal",
            "Modal_3profiles",
            "dash_1",
            "Cluster1"
          ) |
            grepl("^css_signs", VI) |
            grepl("^css_symptoms", VI) |
            grepl("^motor_changes", VI) |
            grepl("^neuropathic_sig", VI) |
            grepl("^skin_dist", VI) |
            grepl("^type_immob", VI)
        ) {
          tibble(
            VD_val = .x$VD_val,
            VI_val = factor(.x$VI_val),
            redcap_event_code = .x$redcap_event_code,
            patient_id = factor(.x$patient_id),
            age = .x$age,
            localization = factor(.x$localization),
            sex = factor(.x$sex)
          )
        } else {
          tibble(
            VD_val = .x$VD_val,
            VI_val = .x$VI_val,
            redcap_event_code = .x$redcap_event_code,
            patient_id = factor(.x$patient_id),
            age = .x$age,
            localization = factor(.x$localization),
            sex = factor(.x$sex)
          )
        }
      )
    ) |>
    mutate(n_sub = map(
      .x = na_check_conv,
      ~ .x |>
        group_by(redcap_event_code) |>
        summarise(n = n()) |>
        pivot_wider(names_from = redcap_event_code, values_from = n, names_prefix = "T")
    )) |>
    mutate(
      mod = map(.x = na_check_conv, ~ { # if no values > no model; else model with the NA filtered data set
        if (nrow(.x) == 0) {
          return(tibble(val = "NA"))
        } else if (is.factor(.x$VI_val) & nlevels(.x$VI_val) <= 1) {
          return(tibble(val = "NA"))
        } else if (nlevels(.x$localization) == 1) {
          return(tidy(lmer(VD_val ~ VI_val + age + sex + redcap_event_code + I(redcap_event_code^2) + (1 | patient_id), data = .x)))
        } else if (nlevels(.x$sex) == 1) {
          return(tidy(lmer(VD_val ~ VI_val + age + redcap_event_code + I(redcap_event_code^2) + (1 | patient_id), data = .x)))
        } else {
          return(tidy(lmer(VD_val ~ VI_val + age + sex + localization + redcap_event_code + I(redcap_event_code^2) + (1 | patient_id), data = .x)))
        }
      })
    ) %>%
    select(VD, VI, mod, n_sub) |>
    unnest(mod) |>
    unnest(n_sub)


  return(mod.quick)
}


# function for univariate analyses of dichotomic outcomes
mod.time.dichotomic.glm <- function(out, data_set = dat, modal = F) {
  
  data_set <- data_set |>
    mutate(across(everything(), as.numeric)) |>
    mutate(redcap_event_code = factor(redcap_event_code)) |>
    filter(redcap_event_code == "4") # only data at T4 are used

  # filtering the name of the outcome from the variables names (if it is also a variable)
  if (any(names(var) == out)) {
    names_var <- names(var |> select(-.data[[out]]))
  } else {
    names_var <- names(var)
  }

  if (modal == F) {
    names_var <- names_var
  } else {
    names_var <- c(names_var, "Modal")
  }

  # creating a data set in long format with VI (variables) and VD (outcome of interest)
  d <- data_set |>
    select(patient_id, redcap_event_code, age, sex, localization, .data[[out]], names_var) |>
    pivot_longer(
      cols = names_var,
      names_to = "VI",
      values_to = "VI_val"
    ) |>
    pivot_longer(
      cols = c(out),
      names_to = "VD",
      values_to = "VD_val"
    )

  # nested data frame for each VI and VD combination


  mod.quick <- d |>
    group_by(VI, VD) |>
    nest() |>
    select(VI, VD, data) |>
    mutate(
      na_check = map(.x = data, ~ na.omit(.x)) # filtering NA from the data set
    ) |>
    mutate(
      na_check_conv = map(
        .x = na_check,
        ~ if (
          VI %in% c(
            "analgesic",
            "budapest_research_criteria",
            "center",
            "conflict",
            "crps_5a",
            "crps_subtypes",
            "crps_type",
            "currently_smoking",
            "dominant_side_affected",
            "family_history_crps",
            "initial_event",
            "localization",
            "personal_historycrps",
            "physiotherapy",
            "psh",
            "psl_affected",
            "reoperated",
            "scintigraphy",
            "sex",
            "skin_color",
            "surgery",
            "triggering_event2",
            "Modal",
            "Modal_3profiles",
            "dash_1",
            "Cluster1"
          ) |
            grepl("^css_signs", VI) |
            grepl("^css_symptoms", VI) |
            grepl("^motor_changes", VI) |
            grepl("^neuropathic_sig", VI) |
            grepl("^skin_dist", VI) |
            grepl("^type_immob", VI)
        ) {
          tibble(
            VD_val = .x$VD_val,
            VI_val = factor(.x$VI_val),
            redcap_event_code = .x$redcap_event_code,
            patient_id = factor(.x$patient_id),
            age = .x$age,
            localization = factor(.x$localization),
            sex = factor(.x$sex)
          )
        } else {
          tibble(
            VD_val = .x$VD_val,
            VI_val = .x$VI_val,
            redcap_event_code = .x$redcap_event_code,
            patient_id = factor(.x$patient_id),
            age = .x$age,
            localization = factor(.x$localization),
            sex = factor(.x$sex)
          )
        }
      )
    ) |>
    mutate(n_sub = map(
      .x = na_check_conv,
      ~ .x |>
        group_by(redcap_event_code) |>
        summarise(n = n()) |>
        pivot_wider(names_from = redcap_event_code, values_from = n, names_prefix = "T")
    )) |>
    mutate(
      mod = map(.x = na_check_conv, ~ { # if no values > no model; else model with the NA filtered data set
        if (nrow(.x) == 0) {
          return(tibble(val = "NA"))
        } else if (is.factor(.x$VI_val) & nlevels(.x$VI_val) <= 1) {
          return(tibble(val = "NA"))
        } else if (nlevels(.x$localization) == 1) {
          return(tidy(glm(VD_val ~ VI_val + age + sex, data = .x, family = "binomial")))
        } else if (nlevels(.x$sex) == 1) {
          return(tidy(glm(VD_val ~ VI_val + age, data = .x, family = "binomial")))
        } else {
          return(tidy(glm(VD_val ~ VI_val + age + sex + localization, data = .x, family = "binomial")))
        }
      })
    ) %>%
    select(VD, VI, mod, n_sub) |>
    unnest(mod) |>
    unnest(n_sub)



  return(mod.quick)
}


```


## Continous outcomes

Loop to repeat univariate analyses for continous outcomes. 


```{r univariate_continous, include = F, eval = F}

# selecting continuous outcomes to analyse
names_outcomes <- dat |> 
  select(bpi_pain_interference, bpi_pain_intensity, css, dichotoumous_diagnosis, EQindex, -work_status, disability) |> names()

# applying function mod.time to all outcomes
list_res_filt_t0 <-  lapply(names_outcomes, function(name) mod.time.new(name, data_set = dat_formatted, modal = T))

# results are stored in a df and only coefficient relative to variables are kept
df_filt_t0   <- bind_rows(list_res_filt_t0) |>
  filter(effect == "fixed")


# output
write_xlsx(df_filt_t0 , path = here("output", paste0("univariate_time0_noworks_",Sys.Date(),".xlsx")))



```


## Dichotomic outcomes

function to examine preditors linked to discrete outcomes.

```{r univariate_dic_glm}

# return to work
res_rtw_glm <- mod.time.dichotomic.glm("RtW", modal = T, data_set = dat_formatted_work)

# disability
res_dic_diag_glm <- mod.time.dichotomic.glm("dichotoumous_diagnosis", modal = T , data_set = dat_formatted)

# output
write_xlsx(res_rtw_glm, path = here("output", paste0("univariate_rtw_glm_",Sys.Date(),".xlsx")))

write_xlsx(res_dic_diag_glm, path = here("output", paste0("univariate_diag_glm_",Sys.Date(),".xlsx")))
```








